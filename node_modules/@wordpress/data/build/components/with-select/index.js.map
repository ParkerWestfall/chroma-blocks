{"version":3,"sources":["/Users/gziolo/PhpstormProjects/gutenberg/packages/data/src/components/with-select/index.js"],"names":["withSelect","mapStateToProps","WrappedComponent","DEFAULT_MERGE_PROPS","getNextMergeProps","props","registry","select","ownProps","ComponentWithSelect","subscribe","mergeProps","canRunSelection","unsubscribe","nextProps","nextState","hasPropsChanged","state","nextMergeProps","setState","Component"],"mappings":";;;;;;;;;AAGA;;;;;;;;;;;;;;AACA;;AACA;;AAKA;;AAVA;;;;AAOA;;;;AAKA;;;;;;;;;;AAUA,IAAMA,UAAU,GAAG,SAAbA,UAAa,CAAEC,eAAF;AAAA,SAAuB,yCAA4B,UAAEC,gBAAF,EAAwB;AAC7F;;;;;;;AAOA,QAAMC,mBAAmB,GAAG,EAA5B;AAEA;;;;;;;;AAOA,aAASC,iBAAT,CAA4BC,KAA5B,EAAoC;AACnC,aACCJ,eAAe,CAAEI,KAAK,CAACC,QAAN,CAAeC,MAAjB,EAAyBF,KAAK,CAACG,QAA/B,CAAf,IACAL,mBAFD;AAIA;;AAED,QAAMM,mBAAmB,GAAG,kCAAqB,UAArB;AAAA;AAAA;AAAA;;AAC3B,sBAAaJ,KAAb,EAAqB;AAAA;;AAAA;AACpB,gHAAOA,KAAP;;AAEA,cAAKK,SAAL;;AAEA,cAAKC,UAAL,GAAkBP,iBAAiB,CAAEC,KAAF,CAAnC;AALoB;AAMpB;;AAP0B;AAAA;AAAA,4CASP;AACnB,eAAKO,eAAL,GAAuB,IAAvB;AACA;AAX0B;AAAA;AAAA,+CAaJ;AACtB,eAAKA,eAAL,GAAuB,KAAvB;AACA,eAAKC,WAAL;AACA;AAhB0B;AAAA;AAAA,8CAkBJC,SAlBI,EAkBOC,SAlBP,EAkBmB;AAC7C,cAAMC,eAAe,GAAG,CAAE,6BAAgB,KAAKX,KAAL,CAAWG,QAA3B,EAAqCM,SAAS,CAACN,QAA/C,CAA1B,CAD6C,CAG7C;AACA;;AACA,cAAK,KAAKS,KAAL,KAAeF,SAAf,IAA4B,CAAEC,eAAnC,EAAqD;AACpD,mBAAO,KAAP;AACA,WAP4C,CAS7C;AACA;;;AACA,cAAKA,eAAL,EAAuB;AACtB,gBAAME,cAAc,GAAGd,iBAAiB,CAAEU,SAAF,CAAxC;;AACA,gBAAK,CAAE,6BAAgB,KAAKH,UAArB,EAAiCO,cAAjC,CAAP,EAA2D;AAC1D;AACA;AACA;AACA;AACA;AACA,mBAAKP,UAAL,GAAkBO,cAAlB;AACA;AACD;;AAED,iBAAO,IAAP;AACA;AA1C0B;AAAA;AAAA,oCA4Cf;AAAA;;AAAA,cACHR,SADG,GACW,KAAKL,KAAL,CAAWC,QADtB,CACHI,SADG;AAGX,eAAKG,WAAL,GAAmBH,SAAS,CAAE,YAAM;AACnC,gBAAK,CAAE,MAAI,CAACE,eAAZ,EAA8B;AAC7B;AACA;;AAED,gBAAMM,cAAc,GAAGd,iBAAiB,CAAE,MAAI,CAACC,KAAP,CAAxC;;AACA,gBAAK,6BAAgB,MAAI,CAACM,UAArB,EAAiCO,cAAjC,CAAL,EAAyD;AACxD;AACA;;AAED,YAAA,MAAI,CAACP,UAAL,GAAkBO,cAAlB,CAVmC,CAYnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,YAAA,MAAI,CAACC,QAAL,CAAe,EAAf;AACA,WArB2B,CAA5B;AAsBA;AArE0B;AAAA;AAAA,iCAuElB;AACR,iBAAO,4BAAC,gBAAD,6BAAuB,KAAKd,KAAL,CAAWG,QAAlC,EAAkD,KAAKG,UAAvD,EAAP;AACA;AAzE0B;AAAA;AAAA,MAAiDS,kBAAjD,EAA5B;AA4EA,WAAO,UAAEZ,QAAF;AAAA,aACN,4BAAC,kCAAD,QACG,UAAEF,QAAF;AAAA,eACD,4BAAC,mBAAD;AACC,UAAA,QAAQ,EAAGE,QADZ;AAEC,UAAA,QAAQ,EAAGF;AAFZ,UADC;AAAA,OADH,CADM;AAAA,KAAP;AAUA,GA9GyC,EA8GvC,YA9GuC,CAAvB;AAAA,CAAnB;;eAgHeN,U","sourcesContent":["/**\n * WordPress dependencies\n */\nimport { Component } from '@wordpress/element';\nimport isShallowEqual from '@wordpress/is-shallow-equal';\nimport { remountOnPropChange, createHigherOrderComponent } from '@wordpress/compose';\n\n/**\n * Internal dependencies\n */\nimport { RegistryConsumer } from '../registry-provider';\n\n/**\n * Higher-order component used to inject state-derived props using registered\n * selectors.\n *\n * @param {Function} mapStateToProps Function called on every state change,\n *                                   expected to return object of props to\n *                                   merge with the component's own props.\n *\n * @return {Component} Enhanced component with merged state data props.\n */\nconst withSelect = ( mapStateToProps ) => createHigherOrderComponent( ( WrappedComponent ) => {\n\t/**\n\t * Default merge props. A constant value is used as the fallback since it\n\t * can be more efficiently shallow compared in case component is repeatedly\n \t * rendered without its own merge props.\n\t *\n\t * @type {Object}\n\t */\n\tconst DEFAULT_MERGE_PROPS = {};\n\n\t/**\n\t * Given a props object, returns the next merge props by mapStateToProps.\n\t *\n\t * @param {Object} props Props to pass as argument to mapStateToProps.\n\t *\n\t * @return {Object} Props to merge into rendered wrapped element.\n\t */\n\tfunction getNextMergeProps( props ) {\n\t\treturn (\n\t\t\tmapStateToProps( props.registry.select, props.ownProps ) ||\n\t\t\tDEFAULT_MERGE_PROPS\n\t\t);\n\t}\n\n\tconst ComponentWithSelect = remountOnPropChange( 'registry' )( class extends Component {\n\t\tconstructor( props ) {\n\t\t\tsuper( props );\n\n\t\t\tthis.subscribe();\n\n\t\t\tthis.mergeProps = getNextMergeProps( props );\n\t\t}\n\n\t\tcomponentDidMount() {\n\t\t\tthis.canRunSelection = true;\n\t\t}\n\n\t\tcomponentWillUnmount() {\n\t\t\tthis.canRunSelection = false;\n\t\t\tthis.unsubscribe();\n\t\t}\n\n\t\tshouldComponentUpdate( nextProps, nextState ) {\n\t\t\tconst hasPropsChanged = ! isShallowEqual( this.props.ownProps, nextProps.ownProps );\n\n\t\t\t// Only render if props have changed or merge props have been updated\n\t\t\t// from the store subscriber.\n\t\t\tif ( this.state === nextState && ! hasPropsChanged ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// If merge props change as a result of the incoming props, they\n\t\t\t// should be reflected as such in the upcoming render.\n\t\t\tif ( hasPropsChanged ) {\n\t\t\t\tconst nextMergeProps = getNextMergeProps( nextProps );\n\t\t\t\tif ( ! isShallowEqual( this.mergeProps, nextMergeProps ) ) {\n\t\t\t\t\t// Side effects are typically discouraged in lifecycle methods, but\n\t\t\t\t\t// this component is heavily used and this is the most performant\n\t\t\t\t\t// code we've found thus far.\n\t\t\t\t\t// Prior efforts to use `getDerivedStateFromProps` have demonstrated\n\t\t\t\t\t// miserable performance.\n\t\t\t\t\tthis.mergeProps = nextMergeProps;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\tsubscribe() {\n\t\t\tconst { subscribe } = this.props.registry;\n\n\t\t\tthis.unsubscribe = subscribe( () => {\n\t\t\t\tif ( ! this.canRunSelection ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst nextMergeProps = getNextMergeProps( this.props );\n\t\t\t\tif ( isShallowEqual( this.mergeProps, nextMergeProps ) ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis.mergeProps = nextMergeProps;\n\n\t\t\t\t// Schedule an update. Merge props are not assigned to state\n\t\t\t\t// because derivation of merge props from incoming props occurs\n\t\t\t\t// within shouldComponentUpdate, where setState is not allowed.\n\t\t\t\t// setState is used here instead of forceUpdate because forceUpdate\n\t\t\t\t// bypasses shouldComponentUpdate altogether, which isn't desireable\n\t\t\t\t// if both state and props change within the same render.\n\t\t\t\t// Unfortunately this requires that next merge props are generated\n\t\t\t\t// twice.\n\t\t\t\tthis.setState( {} );\n\t\t\t} );\n\t\t}\n\n\t\trender() {\n\t\t\treturn <WrappedComponent { ...this.props.ownProps } { ...this.mergeProps } />;\n\t\t}\n\t} );\n\n\treturn ( ownProps ) => (\n\t\t<RegistryConsumer>\n\t\t\t{ ( registry ) => (\n\t\t\t\t<ComponentWithSelect\n\t\t\t\t\townProps={ ownProps }\n\t\t\t\t\tregistry={ registry }\n\t\t\t\t/>\n\t\t\t) }\n\t\t</RegistryConsumer>\n\t);\n}, 'withSelect' );\n\nexport default withSelect;\n"]}