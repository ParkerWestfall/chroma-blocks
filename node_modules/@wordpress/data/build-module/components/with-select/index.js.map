{"version":3,"sources":["/Users/gziolo/PhpstormProjects/gutenberg/packages/data/src/components/with-select/index.js"],"names":["Component","isShallowEqual","remountOnPropChange","createHigherOrderComponent","RegistryConsumer","withSelect","mapStateToProps","WrappedComponent","DEFAULT_MERGE_PROPS","getNextMergeProps","props","registry","select","ownProps","ComponentWithSelect","subscribe","mergeProps","canRunSelection","unsubscribe","nextProps","nextState","hasPropsChanged","state","nextMergeProps","setState"],"mappings":"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","sourcesContent":["/**\n * WordPress dependencies\n */\nimport { Component } from '@wordpress/element';\nimport isShallowEqual from '@wordpress/is-shallow-equal';\nimport { remountOnPropChange, createHigherOrderComponent } from '@wordpress/compose';\n\n/**\n * Internal dependencies\n */\nimport { RegistryConsumer } from '../registry-provider';\n\n/**\n * Higher-order component used to inject state-derived props using registered\n * selectors.\n *\n * @param {Function} mapStateToProps Function called on every state change,\n *                                   expected to return object of props to\n *                                   merge with the component's own props.\n *\n * @return {Component} Enhanced component with merged state data props.\n */\nconst withSelect = ( mapStateToProps ) => createHigherOrderComponent( ( WrappedComponent ) => {\n\t/**\n\t * Default merge props. A constant value is used as the fallback since it\n\t * can be more efficiently shallow compared in case component is repeatedly\n \t * rendered without its own merge props.\n\t *\n\t * @type {Object}\n\t */\n\tconst DEFAULT_MERGE_PROPS = {};\n\n\t/**\n\t * Given a props object, returns the next merge props by mapStateToProps.\n\t *\n\t * @param {Object} props Props to pass as argument to mapStateToProps.\n\t *\n\t * @return {Object} Props to merge into rendered wrapped element.\n\t */\n\tfunction getNextMergeProps( props ) {\n\t\treturn (\n\t\t\tmapStateToProps( props.registry.select, props.ownProps ) ||\n\t\t\tDEFAULT_MERGE_PROPS\n\t\t);\n\t}\n\n\tconst ComponentWithSelect = remountOnPropChange( 'registry' )( class extends Component {\n\t\tconstructor( props ) {\n\t\t\tsuper( props );\n\n\t\t\tthis.subscribe();\n\n\t\t\tthis.mergeProps = getNextMergeProps( props );\n\t\t}\n\n\t\tcomponentDidMount() {\n\t\t\tthis.canRunSelection = true;\n\t\t}\n\n\t\tcomponentWillUnmount() {\n\t\t\tthis.canRunSelection = false;\n\t\t\tthis.unsubscribe();\n\t\t}\n\n\t\tshouldComponentUpdate( nextProps, nextState ) {\n\t\t\tconst hasPropsChanged = ! isShallowEqual( this.props.ownProps, nextProps.ownProps );\n\n\t\t\t// Only render if props have changed or merge props have been updated\n\t\t\t// from the store subscriber.\n\t\t\tif ( this.state === nextState && ! hasPropsChanged ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// If merge props change as a result of the incoming props, they\n\t\t\t// should be reflected as such in the upcoming render.\n\t\t\tif ( hasPropsChanged ) {\n\t\t\t\tconst nextMergeProps = getNextMergeProps( nextProps );\n\t\t\t\tif ( ! isShallowEqual( this.mergeProps, nextMergeProps ) ) {\n\t\t\t\t\t// Side effects are typically discouraged in lifecycle methods, but\n\t\t\t\t\t// this component is heavily used and this is the most performant\n\t\t\t\t\t// code we've found thus far.\n\t\t\t\t\t// Prior efforts to use `getDerivedStateFromProps` have demonstrated\n\t\t\t\t\t// miserable performance.\n\t\t\t\t\tthis.mergeProps = nextMergeProps;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\tsubscribe() {\n\t\t\tconst { subscribe } = this.props.registry;\n\n\t\t\tthis.unsubscribe = subscribe( () => {\n\t\t\t\tif ( ! this.canRunSelection ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst nextMergeProps = getNextMergeProps( this.props );\n\t\t\t\tif ( isShallowEqual( this.mergeProps, nextMergeProps ) ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis.mergeProps = nextMergeProps;\n\n\t\t\t\t// Schedule an update. Merge props are not assigned to state\n\t\t\t\t// because derivation of merge props from incoming props occurs\n\t\t\t\t// within shouldComponentUpdate, where setState is not allowed.\n\t\t\t\t// setState is used here instead of forceUpdate because forceUpdate\n\t\t\t\t// bypasses shouldComponentUpdate altogether, which isn't desireable\n\t\t\t\t// if both state and props change within the same render.\n\t\t\t\t// Unfortunately this requires that next merge props are generated\n\t\t\t\t// twice.\n\t\t\t\tthis.setState( {} );\n\t\t\t} );\n\t\t}\n\n\t\trender() {\n\t\t\treturn <WrappedComponent { ...this.props.ownProps } { ...this.mergeProps } />;\n\t\t}\n\t} );\n\n\treturn ( ownProps ) => (\n\t\t<RegistryConsumer>\n\t\t\t{ ( registry ) => (\n\t\t\t\t<ComponentWithSelect\n\t\t\t\t\townProps={ ownProps }\n\t\t\t\t\tregistry={ registry }\n\t\t\t\t/>\n\t\t\t) }\n\t\t</RegistryConsumer>\n\t);\n}, 'withSelect' );\n\nexport default withSelect;\n"]}