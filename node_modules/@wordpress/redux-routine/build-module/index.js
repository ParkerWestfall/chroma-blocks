import _Promise from "@babel/runtime-corejs2/core-js/promise";

/**
 * Internal dependencies
 */
import isGenerator from './is-generator';
import castError from './cast-error';
/**
 * Creates a Redux middleware, given an object of controls where each key is an
 * action type for which to act upon, the value a function which returns either
 * a promise which is to resolve when evaluation of the action should continue,
 * or a value. The value or resolved promise value is assigned on the return
 * value of the yield assignment. If the control handler returns undefined, the
 * execution is not continued.
 *
 * @param {Object} controls Object of control handlers.
 *
 * @return {Function} Redux middleware function.
 */

export default function createMiddleware() {
  var controls = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return function (store) {
    return function (next) {
      return function (action) {
        if (!isGenerator(action)) {
          return next(action);
        }

        function step(nextAction) {
          if (!nextAction) {
            return;
          }

          var control = controls[nextAction.type];

          if (typeof control === 'function') {
            var routine = control(nextAction);

            if (routine instanceof _Promise) {
              // Async control routine awaits resolution.
              routine.then(function (result) {
                return step(action.next(result).value);
              }, function (error) {
                return action.throw(castError(error));
              });
            } else if (routine !== undefined) {
              // Sync control routine steps synchronously.
              step(action.next(routine).value);
            }
          } else {
            // Uncontrolled action is dispatched.
            store.dispatch(nextAction);
            step(action.next().value);
          }
        }

        step(action.next().value);
      };
    };
  };
}
//# sourceMappingURL=index.js.map